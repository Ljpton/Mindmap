<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8" />
    <title>Portfolio 2025</title>
</head>
<body>
    <div id="container" style="width: 100%; height: 95vh;"></div>
</body>
    
<script src="libraries/d3.v7.min.js"></script>

<script type="module">

const baseNodes = [
    { id: "Leon", group: "1", width: "48", height: "60"},
    { id: "Games", group: "2", width: "40", height: "50"},
    { id: "Music", group: "3", width: "40", height: "50"},
    { id: "Art", group: "4", width: "40", height: "50"}
]

const baseLinks = [
    { source: "Leon", target: "Games", distance: "200" },
    { source: "Leon", target: "Music", distance: "200" },
    { source: "Leon", target: "Art", distance: "200" }
]

const links = baseLinks.map(d => ({...d}));
const nodes = baseNodes.map(d => ({...d}));

// Color scale
const color = d3.scaleOrdinal(d3.schemeCategory10);

// Declare the graph dimensions
var width = window.innerWidth;
var height = window.innerHeight;

window.addEventListener('resize', function(event) {
    width = window.innerWidth;
    height = window.innerHeight
}, true);

// Create a simulation with several forces.
const simulation = d3.forceSimulation(nodes)
    //.force("link", d3.forceLink(links).id(d => d.id).distance(d => d.distance))
    .force("charge", d3.forceManyBody().strength(-100))
    .force("center", d3.forceCenter(width / 2, height / 2))
    .on("tick", ticked);

// Create the SVG in container.
const svg = d3.create("svg")
    .attr("width", "100%")
    .attr("height", "100%")

// Append the SVG element.
container.append(svg.node());

// Add a line for each link, and a circle for each node.
const link = svg.append("g")
    .attr("stroke", "#000")
    .attr("stroke-opacity", .6)
    .selectAll()
    .data(links)
    .join("line")
    .attr("stroke-width", 1.5);

const node = svg.append("g")
    .attr("stroke", "#000")
    .attr("stroke-width", 1.5)
    .selectAll()
    .data(nodes)
    .join("rect")
    .attr("width", d => d.width)
    .attr("height", d => d.height)
    .attr("fill", d => color(d.group));

node.append("title")
    .text(d => d.id);

// Add a drag behavior.
node.call(d3.drag()
    .on("start", dragstarted)
    .on("drag", dragged)
    .on("end", dragended));

// Set the position attributes of links and nodes each time the simulation ticks.
function ticked() {
    link
        .attr("x1", d => d.source.x + d.source.width / 2)
        .attr("y1", d => d.source.y + d.source.height / 2)
        .attr("x2", d => d.target.x + d.target.width / 2)
        .attr("y2", d => d.target.y + d.target.height / 2);
    node
        .attr("x", d => d.x)
        .attr("y", d => d.y);
}

// Reheat the simulation when drag starts, and fix the subject position.
function dragstarted(event) {
    if (!event.active) simulation.alphaTarget(0.3).restart();
    event.subject.fx = event.subject.x;
    event.subject.fy = event.subject.y;
}

// Update the subject (dragged node) position during drag.
function dragged(event) {
    event.subject.fx = event.x;
    event.subject.fy = event.y;
}

// Restore the target alpha so the simulation cools after dragging ends.
// Unfix the subject position now that itâ€™s no longer being dragged.
function dragended(event) {
    if (!event.active) simulation.alphaTarget(0);
    event.subject.fx = null;
    event.subject.fy = null;
}

</script>

</html>