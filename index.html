<!DOCTYPE html>
<html lang="de">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>mindmap portfolio</title>
  <link rel="stylesheet" href="css/style.css" />
</head>

<body>
  <div id="overlay">
    <div class="content">
      <div class="title-bar">
        <div id="overlay-title"></div>
        <span class="close-btn">✖</span>
      </div>
      <div class="scroll-area">  
        <div id="overlay-logline"></div>
        <p id="overlay-text"></p>
      </div>
    </div>
  </div>
  <div id="footer">
    <div>
      <div style="width: 115px;">Leon's portfolio</div>
      <div id="social-media">
        <a href="https://github.com/Ljpton"><img src="img/github_logo.png" alt="github"></a>
        <a href="https://bsky.app/profile/fernofai.bsky.social"><img src="img/bluesky_logo.png" alt="bluesky"></a>
        <a href="https://www.linkedin.com/in/leon-unger-6a4137269/"><img src="img/linkedin_logo.png" alt="linkedin"></a>
      </div>
    </div>
    <a href="legal.html">legal notice</a>
  </div>

  <!-- D3.js laden -->
  <script src="https://d3js.org/d3.v7.min.js"></script>

  <script>
    // Overlay-Elemente
    const overlay = d3.select('#overlay');
    const titleEl = d3.select('#overlay-title');
    const loglineEl = d3.select('#overlay-logline');
    const textEl = d3.select('#overlay-text');
    const closeBtn = d3.select('#overlay .close-btn');
    const contentEl = d3.select('#overlay .content');

    function parseRichText(text) {
      return text
      // Bilder
      .replace(/\[\[img:(.*?)\]\]/g, '<div class="inline-content-container"><img class="inline-content" src="$1"/></div>')
      // GIFs (wie Bilder behandelt)
      .replace(/\[\[gif:(.*?)\]\]/g, '<div class="inline-content-container"><img class="inline-content" src="$1" alt="GIF"/></div>')
      // YouTube-Videos (Einbettung per iframe)
      .replace(/\[\[yt:(.*?)\]\]/g, '<div class="inline-content-container"><iframe width="1600" height="900" class="inline-content" src="$1" frameborder="0" allowfullscreen></iframe></div>')
      
      .replace(/\[\[link:(.*?)(?:\|(.*?))?\]\]/g, (match, url, text) => {
        const linkText = text || url;
        return `<a href="${url}" class="inline-link" target="_blank" rel="noopener noreferrer">${linkText}</a>`;
      });
    }
    
    closeBtn.on('click', () => hideOverlay());
    overlay.on('click', (event) => {
      if (event.target.id === 'overlay') hideOverlay();
    });

    function showOverlay(d) {
      titleEl.text(d.title);
      loglineEl.text(d.logline || '');
      textEl.html(parseRichText(d.text) || '');
      overlay.style('display', 'block');
      contentEl.style('border-color', d.color);
    }
    function hideOverlay() {
      overlay.style('display', 'none');
      // Auswahl zurücksetzen
      container.selectAll('.node').classed('selected', false);
    }

    const svg = d3.select('body').append('svg')
      .attr('width', window.innerWidth)
      .attr('height', window.innerHeight);
          
    const container = svg.append('g');

    // Klick auf Hintergrund -> Deselektieren
    svg.on('click', () => hideOverlay());
    container.on('click', (event) => {
      // Verhindern, dass Klicks auf Nodes hier landen (stopPropagation in Node-Handler)
      if (event.target.tagName === 'svg') {
        hideOverlay();
      }
    });

    const zoom = d3.zoom()
      .scaleExtent([0.1, 10])
      .on('zoom', ({ transform }) => container.attr('transform', transform));
    svg.call(zoom);
    
    // Daten aus JSON laden
    fetch('nodes.json')
      .then(response => response.json())
      .then(data => {
        const nodes = data.nodes;
        const links = [];
        nodes.forEach(node => {
          Object.values(node.links).forEach(targetId => {
            links.push({ source: node.id.toString(), target: targetId.toString() });
          });
        });

        // Map von id→Node-Objekt
        const nodeById = new Map(nodes.map(d => [d.id.toString(), d]));
        const linksResolved = links.map(l => ({
          source: nodeById.get(l.source),
          target: nodeById.get(l.target)
        }));

        // Anfangspositionen: nutzen xoffset/yoffset oder Mitte
        nodes.forEach(d => {
          d.x = window.innerWidth / 2 + ((d.xoffset !== undefined) ? +d.xoffset : 0);
          d.y = window.innerHeight / 2 + ((d.yoffset !== undefined) ? +d.yoffset : 0);
        });

        // Links zeichnen
        const linkSel = container.append('g')
          .attr('class', 'links')
          .selectAll('line')
          .data(linksResolved)
          .enter().append('line')
          .attr('class', 'link')
          .attr('stroke', '#999')
          .attr('stroke-width', 1.2);

        // Nodes zeichnen
        const nodeGroup = container.append('g')
          .attr('class', 'nodes')
          .selectAll('g')
          .data(nodes)
          .enter().append('g')
          .attr('class', 'node')
          .attr('transform', d => `translate(${+d.x},${+d.y})`)
          .on('click', (event, d) => {
            event.stopPropagation();
            const isSelected = d3.select(event.currentTarget).classed('selected');
            container.selectAll('.node').classed('selected', false);
            if (!isSelected) {
              d3.select(event.currentTarget).classed('selected', true);
              showOverlay(d);
            } else {
              hideOverlay();
            }
          })
          .call(d3.drag()
            .on('start', dragstarted)
            .on('drag', dragged)
            .on('end', dragended)
          );

        // Größe und Layout basierend auf size-Attribut
        const padding = 8;
        const titleHeight = 32;
        const thumbSize = d => +d.size;
        // Gesamtbreite = Thumbnail plus seitlicher Padding
        const nodeWidth = d => thumbSize(d) + padding * 2;
        // Gesamthöhe = Titelbereich + Thumbnail + oberer/unterer Padding
        const nodeHeight = d => titleHeight + thumbSize(d) + padding * 2;

        nodeGroup.append('rect')
          .attr('x', d => -nodeWidth(d) / 2)
          .attr('y', d => -nodeHeight(d) / 2)
          .attr('width', d => nodeWidth(d))
          .attr('height', d => nodeHeight(d))
          .attr('fill', d => d.color);

        nodeGroup.append('text')
          .attr('x', 0)
          .attr('y', d => -nodeHeight(d) / 2 + titleHeight / 2 + padding / 2)
          .attr('text-anchor', 'middle')
          .attr('dominant-baseline', 'middle')
          .attr('font-size', '12px')
          .attr('fill', '#fff')
          .each(function(d) { // Truncate long titles
            const textEl = d3.select(this);
            let txt = d.title;
            textEl.text(txt);
            const maxW = nodeWidth(d) - padding * 2;
            while (this.getComputedTextLength() > maxW && txt.length > 0) {
              txt = txt.slice(0, -1);
              textEl.text(txt + '…');
            }
          });

        nodeGroup.append('image')
          .attr('href', d => d.thumbnail)
          .attr('x', d => -thumbSize(d) / 2)
          .attr('y', d => -nodeHeight(d) / 2 + titleHeight + padding)
          .attr('width', d => thumbSize(d))
          .attr('height', d => thumbSize(d));

        // Links einmalig initial setzen
        updateLinks();

        function updateLinks() {
          linkSel
            .attr('x1', d => +d.source.x)
            .attr('y1', d => +d.source.y)
            .attr('x2', d => +d.target.x)
            .attr('y2', d => +d.target.y);
        }

        // Drag‐Callback ohne Simulation
        function dragstarted(event, d) {
          d3.select(this).raise();
        }

        function dragged(event, d) {
          d.x = +event.x;
          d.y = +event.y;
          d3.select(this).attr('transform', `translate(${d.x},${d.y})`);
          updateLinks();
        }

        function dragended(event, d) { }

        // Resize: Canvas anpassen, Links neu zeichnen
        window.addEventListener('resize', () => {
          svg.attr('width', window.innerWidth).attr('height', window.innerHeight);
          updateLinks();
        });
      })
      .catch(error => console.error('Fehler beim Laden der Daten:', error));
  </script>
</body>

</html>
